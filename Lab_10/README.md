Лабораторная работа 10. Методы оптимизации вычисления кода с помощью потоков, процессов, Cython, отпускания GIL

Цель работы: исследовать методы оптимизации вычисления кода, используя потоки, процессы, Cython и отключение GIL на основе сравнения времени вычисления функции численного интегрирования методом прямоугольников, реализованной на чистом Python.

Отчёт


Итерация 1, временные характеристики:


------------------------------------------------------------
Замеры integrate() с разным числом итераций:
------------------------------------------------------------
1K итераций: 0.000056 секунд

10K итераций: 0.000591 секунд

100K итераций: 0.006064 секунд

1M итераций: 0.059448 секунд

---------------------------------------------------------------------------
Сравнение потоков и процессов:
---------------------------------------------------------------------------
n_jobs=2:
  Потоки: 0.0032 сек, результат=2.000000
  Процессы: 0.0809 сек, результат=2.000000

n_jobs=4:
  Потоки: 0.0010 сек, результат=2.000000
  Процессы: 0.0758 сек, результат=2.000000

n_jobs=6:
  Потоки: 0.0008 сек, результат=2.000000
  Процессы: 0.0853 сек, результат=2.000000

n_jobs=8:
  Потоки: 0.0015 сек, результат=2.000000
  Процессы: 0.0946 сек, результат=2.000000


Итерация 2-3: оптимизация с помощью потоков и процессов находится в файле: Optimization_For_Integration.py 

Итерация 4: запуск замеров по Cython находится в файле: run_cython_benchmark.py


Итерация 5: запуск замеров с использованием noGil находится в файле: run_nogil_benchmark.py

* При численном интегрировании примитивы синхронизации (мьютексы, семафоры) не нужны, потому что:

1. Данные разделены (data parallelism):
   - Каждый поток работает со своим интервалом
   - Нет общей изменяемой структуры данных
   - Результаты объединяются только в конце

2. Нет состояния гонки (race condition):
   - Каждый аккумулятор - локальная переменная
   - Суммирование результатов происходит ПОСЛЕ вычислений
   - Нет одновременной записи в одну переменную
